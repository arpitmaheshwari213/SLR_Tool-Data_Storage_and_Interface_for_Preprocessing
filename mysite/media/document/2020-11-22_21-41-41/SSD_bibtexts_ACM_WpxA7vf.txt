@inproceedings{10.1145/2384716.2384763,
author = {Imam, Shams Mahmood},
title = {CnC-Python: Multicore Programming with High Productivity},
year = {2012},
isbn = {9781450315630},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2384716.2384763},
doi = {10.1145/2384716.2384763},
abstract = {We present CnC-Python (CP), an approach to implicit multicore parallelism based on Intel's Concurrent Collections model. CP enables programmers to achieve task, data and pipeline parallelism in a declarative fashion while only being required to describe the program as a coordination graph with serial Python code for individual nodes.},
booktitle = {Proceedings of the 3rd Annual Conference on Systems, Programming, and Applications: Software for Humanity},
pages = {111–112},
numpages = {2},
keywords = {cnc-python, parallel programming, concurrent collections, python},
location = {Tucson, Arizona, USA},
series = {SPLASH '12}
}

@inproceedings{10.1145/2635648.2635660,
author = {Ramos, Pedro Palma and Leit\~{a}o, Ant\'{o}nio Menezes},
title = {Reaching Python from Racket},
year = {2014},
isbn = {9781450329316},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2635648.2635660},
doi = {10.1145/2635648.2635660},
abstract = {Racket is a descendant of Scheme, a language that has been widely used to teach computer science. Recently, the Python language has taken over this role, mainly due to its huge standard library and the great number of third-party libraries available. Given that the development of equivalent libraries for Racket is an enormous task that cannot be currently done in an acceptable time frame, the next best option is to allow the Racket platform to use Python programs and libraries.We have been developing an implementation of Python for the Racket platform based on a source-to-source compiler. In order to provide good performance and good interoperability with the Racket platform, the runtime libraries are being implemented over Racket data-types. This, however, entails implementing all of Python's standard library on Racket and it does not provide access to popular Python libraries implemented using C module extensions (such as Numpy and SciPy).This paper presents an alternative approach that allows libraries from Python's reference implementation to be imported and used in our Racket implementation of Python, immediately providing access to all of Python's standard library and every third-party library, including NumPy and SciPy.The proposed solution involves importing Python module objects directly from Python's virtual machine, by calling the Python/C API through Racket's Foreign Function Interface, and converting them to objects usable by our Racket runtime libraries, making them compatible with the Racket platform.This compatibility layer therefore relies on relatively expensive foreign function calls to Python's libraries, but our performance tests show that the overhead introduced by them is quite low and, for most cases, it can be minimized in order to attain the same performance as Python's reference implementation.},
booktitle = {Proceedings of ILC 2014 on 8th International Lisp Conference},
pages = {32–38},
numpages = {7},
keywords = {Interoperability, Racket, Python},
location = {Montreal, QC, Canada},
series = {ILC '14}
}

@article{10.5555/2188385.2343710,
author = {De Smedt, Tom and Daelemans, Walter},
title = {Pattern for Python},
year = {2012},
issue_date = {3/1/2012},
publisher = {JMLR.org},
volume = {13},
number = {null},
issn = {1532-4435},
abstract = {Pattern is a package for Python 2.4+ with functionality for web mining (Google + Twitter + Wikipedia, web spider, HTML DOM parser), natural language processing (tagger/chunker, n-gram search, sentiment analysis, WordNet), machine learning (vector space model, k-means clustering, Naive Bayes + k-NN + SVM classifiers) and network analysis (graph centrality and visualization). It is well documented and bundled with 30+ examples and 350+ unit tests. The source code is licensed under BSD and available from http://www.clips.ua.ac.be/pages/pattern.},
journal = {J. Mach. Learn. Res.},
month = jun,
pages = {2063–2067},
numpages = {5},
keywords = {python, data mining, machine learning, graph networks, natural language processing}
}

@inproceedings{10.1145/611892.611996,
author = {Blank, Douglas and Meeden, Lisa and Kumar, Deepak},
title = {Python Robotics: An Environment for Exploring Robotics beyond LEGOs},
year = {2003},
isbn = {158113648X},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/611892.611996},
doi = {10.1145/611892.611996},
abstract = {This paper describes Pyro, a robotics programming environment designed to allow inexperienced undergraduates to explore topics in advanced robotics. Pyro, which stands for Python Robotics, runs on a number of advanced robotics platforms. In addition, programs in Pyro can abstract away low-level details such that individual programs can work unchanged across very different robotics hardware. Results of using Pyro in an undergraduate course are discussed.},
booktitle = {Proceedings of the 34th SIGCSE Technical Symposium on Computer Science Education},
pages = {317–321},
numpages = {5},
keywords = {robotics, pedagogy, python},
location = {Reno, Navada, USA},
series = {SIGCSE '03}
}

@article{10.1145/792548.611996,
author = {Blank, Douglas and Meeden, Lisa and Kumar, Deepak},
title = {Python Robotics: An Environment for Exploring Robotics beyond LEGOs},
year = {2003},
issue_date = {January 2003},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {35},
number = {1},
issn = {0097-8418},
url = {https://doi.org/10.1145/792548.611996},
doi = {10.1145/792548.611996},
abstract = {This paper describes Pyro, a robotics programming environment designed to allow inexperienced undergraduates to explore topics in advanced robotics. Pyro, which stands for Python Robotics, runs on a number of advanced robotics platforms. In addition, programs in Pyro can abstract away low-level details such that individual programs can work unchanged across very different robotics hardware. Results of using Pyro in an undergraduate course are discussed.},
journal = {SIGCSE Bull.},
month = jan,
pages = {317–321},
numpages = {5},
keywords = {python, robotics, pedagogy}
}

@article{10.5555/2503308.2343710,
author = {De Smedt, Tom and Daelemans, Walter},
title = {Pattern for Python},
year = {2012},
issue_date = {January 2012},
publisher = {JMLR.org},
volume = {13},
number = {1},
issn = {1532-4435},
abstract = {Pattern is a package for Python 2.4+ with functionality for web mining (Google + Twitter + Wikipedia, web spider, HTML DOM parser), natural language processing (tagger/chunker, n-gram search, sentiment analysis, WordNet), machine learning (vector space model, k-means clustering, Naive Bayes + k-NN + SVM classifiers) and network analysis (graph centrality and visualization). It is well documented and bundled with 30+ examples and 350+ unit tests. The source code is licensed under BSD and available from http://www.clips.ua.ac.be/pages/pattern.},
journal = {J. Mach. Learn. Res.},
month = jun,
pages = {2063–2067},
numpages = {5},
keywords = {data mining, natural language processing, machine learning, graph networks, python}
}

@inproceedings{10.1145/3149869.3149874,
author = {Schoun, Breawn and Transue, Shane and Choi, Min-Hyung},
title = {Real-Time Thermal Medium-Based Breathing Analysis with Python},
year = {2017},
isbn = {9781450351249},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3149869.3149874},
doi = {10.1145/3149869.3149874},
abstract = {Respiration monitoring is an important physiological measurement taken to determine the health of an individual. In clinical sleep studies, respiration activity is monitored to detect sleep disorders such as sleep apnea and respiratory conditions such as Chronic Obstructive Pulmonary Disease (COPD). Existing methods of respiration monitoring either place sensors on the patient's body, causing discomfort to the patient, or monitor respiration remotely with lower accuracy. We present a method of respiratory analysis that is non-contact, but also measures the exhaled air of a human subject directly through a medium-based exhale visualization technique. In this method, we place a thin medium perpendicular to the exhaled airflow of an individual, and use a thermal camera to record the heat signature from the exhaled breath on the opposite side of the material. Respiratory behaviors are extracted from the thermal data in real time using Python. Our prototype is an embedded, low-power device that performs image and signal processing in realtime with Python, making use of powerful existing Python modules for scientific computing and visualization. Our proposed respiration monitoring technique accurately reports breathing rate, and may provide other metrics not obtainable through other non-contact methods. This method can be useful for medical applications where long-term respiratory analysis is necessary, and for applications that require additional information about breathing behavior.},
booktitle = {Proceedings of the 7th Workshop on Python for High-Performance and Scientific Computing},
articleno = {5},
numpages = {9},
keywords = {medium, thermal, Respiration, exhale, Python, medical},
location = {Denver, CO, USA},
series = {PyHPC'17}
}

@inproceedings{10.1145/1734263.1734437,
author = {Enbody, Richard J. and Punch, William F.},
title = {Performance of Python CS1 Students in Mid-Level Non-Python CS Courses},
year = {2010},
isbn = {9781450300063},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1734263.1734437},
doi = {10.1145/1734263.1734437},
abstract = {If you change the CS1 language to Python, what is the impact on the rest of the curriculum? In earlier work we examined the impact of changing CS1 from C++ to Python while leaving CS2 in C++. We found that Python-prepared CS1 students fared no differently in CS2 than students whose CS1 course was in C++, even though CS2 was taught in C++ and covered the same topics as in previous years. Was that an anomaly? What happens in the next tier of courses? When our CS1 was first changed to Python there were many students who had taken CS1 in C++ still in the system. The result is that there is a cadre of students with either CS1 in Python or CS1 in C++ moving together through our curriculum. This one-time occurrence is an opportunity to study the students with many variables fixed. Our next tier of courses is a C-based computer organization course, a C++ based object-oriented software design course, and a data structures course. We found that the students who started with Python fared as well as the CS1 C++ students. As before, the best predictor of performance was their college GPA. Python versus C++ CS1 preparation was not a predictor of performance in any course. We conclude again that in our C++ based curriculum changing CS1 to Python had no negative impact on student performance and did not require any significant change in those subsequent courses.},
booktitle = {Proceedings of the 41st ACM Technical Symposium on Computer Science Education},
pages = {520–523},
numpages = {4},
keywords = {python, introduction to programming, curriculum, cs1},
location = {Milwaukee, Wisconsin, USA},
series = {SIGCSE '10}
}

@inproceedings{10.1145/2617548.2617552,
author = {Barany, Gerg\"{o}},
title = {Python Interpreter Performance Deconstructed},
year = {2014},
isbn = {9781450329163},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2617548.2617552},
doi = {10.1145/2617548.2617552},
abstract = {The Python programming language is known for performing poorly on many tasks. While to some extent this is to be expected from a dynamic language, it is not clear how much each dynamic feature contributes to the costs of interpreting Python. In this study we attempt to quantify the costs of language features such as dynamic typing, reference counting for memory management, boxing of numbers, and late binding of function calls.We use an experimental compilation framework for Python that can make use of type annotations provided by the user to specialize the program as well as elide unnecessary reference counting operations and function lookups. The compiled programs run within the Python interpreter and use its internal API to implement language semantics. By separately enabling and disabling compiler optimizations, we can thus measure how much each language feature contributes to total execution time in the interpreter.We find that a boxed representation of numbers as heap objects is the single most costly language feature on numeric codes, accounting for up to 43% of total execution time in our benchmark set. On symbolic object-oriented code, late binding of function and method calls costs up to 30%. Redundant reference counting, dynamic type checks, and Python's elaborate function calling convention have comparatively smaller costs.},
booktitle = {Proceedings of the Workshop on Dynamic Languages and Applications},
pages = {1–9},
numpages = {9},
keywords = {dynamic programming languages, reference counting, unboxing, Python, interpreters},
location = {Edinburgh, United Kingdom},
series = {Dyla'14}
}

@inproceedings{10.1145/3079368.3079370,
author = {Niephaus, Fabio},
title = {Towards A Squeak/Smalltalk-Based Python IDE: An Interpreter-Level Integration of Python with Smalltalk},
year = {2017},
isbn = {9781450348362},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3079368.3079370},
doi = {10.1145/3079368.3079370},
abstract = {In this paper, we present how we integrated Python with a Smalltalk environment on interpreter level in order to be able to reuse concepts and tools from Smalltalk for Python development.},
booktitle = {Companion to the First International Conference on the Art, Science and Engineering of Programming},
articleno = {37},
numpages = {2},
keywords = {IDE, Python, debugging, Smalltalk, interpreters},
location = {Brussels, Belgium},
series = {Programming '17}
}

@inproceedings{10.1145/1140124.1140177,
author = {Radenski, Atanas},
title = {"Python First": A Lab-Based Digital Introduction to Computer Science},
year = {2006},
isbn = {1595930558},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1140124.1140177},
doi = {10.1145/1140124.1140177},
abstract = {The emphasis on Java and other commercial languages in CS1 has established the perception of computer science as a dry and technically difficult discipline among undecided students who are still seeking careers. This may not be a big problem during an enrolment boom, but in times of decreased enrolment such negative perception may have a devastating effect on computer science programs and therefore should not be ignored. We have made our CS1 course offerings more attractive to students (1) by introducing an easy to learn yet effective scripting language - Python, (2) by making all course resources available in a comprehensive online study pack, and (3) by offering an extensive set of detailed and easy to follow self-guided labs. Our custom-designed online study pack comprises a wealth of new, original learning modules: extensive e-texts, detailed self-guided labs, numerous sample programs, quizzes, and slides. Our recent student survey demonstrates that students like and prefer Python as a first language and that they also percept the online study pack as very beneficial. Our "Python First" course, originally required for computer science majors, has been so well received that it has been recently approved as a general education science elective, thus opening new recruitment opportunities for the computer science major. Our "Python First" digital pack is published online at http://studypack.com.},
booktitle = {Proceedings of the 11th Annual SIGCSE Conference on Innovation and Technology in Computer Science Education},
pages = {197–201},
numpages = {5},
keywords = {CS2, Python, self-guided lab, online study pack, Java, CS1, OOP},
location = {Bologna, Italy},
series = {ITICSE '06}
}

@article{10.1145/1140123.1140177,
author = {Radenski, Atanas},
title = {"Python First": A Lab-Based Digital Introduction to Computer Science},
year = {2006},
issue_date = {September 2006},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {38},
number = {3},
issn = {0097-8418},
url = {https://doi.org/10.1145/1140123.1140177},
doi = {10.1145/1140123.1140177},
abstract = {The emphasis on Java and other commercial languages in CS1 has established the perception of computer science as a dry and technically difficult discipline among undecided students who are still seeking careers. This may not be a big problem during an enrolment boom, but in times of decreased enrolment such negative perception may have a devastating effect on computer science programs and therefore should not be ignored. We have made our CS1 course offerings more attractive to students (1) by introducing an easy to learn yet effective scripting language - Python, (2) by making all course resources available in a comprehensive online study pack, and (3) by offering an extensive set of detailed and easy to follow self-guided labs. Our custom-designed online study pack comprises a wealth of new, original learning modules: extensive e-texts, detailed self-guided labs, numerous sample programs, quizzes, and slides. Our recent student survey demonstrates that students like and prefer Python as a first language and that they also percept the online study pack as very beneficial. Our "Python First" course, originally required for computer science majors, has been so well received that it has been recently approved as a general education science elective, thus opening new recruitment opportunities for the computer science major. Our "Python First" digital pack is published online at http://studypack.com.},
journal = {SIGCSE Bull.},
month = jun,
pages = {197–201},
numpages = {5},
keywords = {CS1, CS2, Java, OOP, Python, online study pack, self-guided lab}
}

@inproceedings{10.5555/3019083.3019089,
author = {Smith, Ross},
title = {Performance of MPI Codes Written in Python with NumPy and Mpi4py},
year = {2016},
isbn = {9781509052202},
publisher = {IEEE Press},
abstract = {Python is an interpreted language that has become more commonly used within HPC applications. Python benefits from the ability to write extension modules in C, which can further use optimized libraries that have been written in other compiled languages. For HPC users, two of the most common extensions are NumPy and mpi4py. It is possible to write a full computational kernel in a compiled language and then build that kernel into an extension module. However, this process requires not only the kernel be written in the compiled language, but also the interface between the kernel and Python be implemented. If possible, it would be preferable to achieve similar performance by writing the code directly in Python using readily available performant modules. In this work the performance differences between compiled codes and codes written using Python3 and commonly available modules, most notably NumPy and mpi4py, are investigated. Additionally, the performance of an open source Python stack is compared to the recently announced Intel Python3 distribution.},
booktitle = {Proceedings of the 6th Workshop on Python for High-Performance and Scientific Computing},
pages = {45–51},
numpages = {7},
keywords = {MPI, HPC, mpi4py, Python, Intel Python},
location = {Salt Lake City, Utah},
series = {PyHPC '16}
}

@inproceedings{10.1145/3149869.3149877,
author = {Sehrish, S. and Kowalkowski, J. and Paterno, M. and Green, C.},
title = {Python and HPC for High Energy Physics Data Analyses},
year = {2017},
isbn = {9781450351249},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3149869.3149877},
doi = {10.1145/3149869.3149877},
abstract = {High level abstractions in Python that can utilize computing hardware well seem to be an attractive option for writing data reduction and analysis tasks. In this paper, we explore the features available in Python which are useful and efficient for end user analysis in High Energy Physics (HEP). A typical vertical slice of an HEP data analysis is somewhat fragmented: the state of the reduction/analysis process must be saved at certain stages to allow for selective reprocessing of only parts of a generally time-consuming workflow. Also, algorithms tend to to be modular because of the heterogeneous nature of most detectors and the need to analyze different parts of the detector separately before combining the information. This fragmentation causes difficulties for interactive data analysis, and as data sets increase in size and complexity (O10 TiB for a "small" neutrino experiment to the O10 PiB currently held by the CMS experiment at the LHC), data analysis methods traditional to the field must evolve to make optimum use of emerging HPC technologies and platforms. Mainstream big data tools, while suggesting a direction in terms of what can be done if an entire data set can be available across a system and analysed with high-level programming abstractions, are not designed with either scientific computing generally, or modern HPC platform features in particular, such as data caching levels, in mind.Our example HPC use case is a search for a new elementary particle which might explain the phenomenon known as "Dark Matter". Using data from the CMS detector, we will use HDF5 as our input data format, and MPI with Python to implement our use case.},
booktitle = {Proceedings of the 7th Workshop on Python for High-Performance and Scientific Computing},
articleno = {8},
numpages = {8},
keywords = {pandas, HEP analysis, Python, numpy, HDF5, MPI, HPC, mpi4py},
location = {Denver, CO, USA},
series = {PyHPC'17}
}

@inproceedings{10.1145/2445196.2445368,
author = {Guo, Philip J.},
title = {Online Python Tutor: Embeddable Web-Based Program Visualization for Cs Education},
year = {2013},
isbn = {9781450318686},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2445196.2445368},
doi = {10.1145/2445196.2445368},
abstract = {This paper presents Online Python Tutor, a web-based program visualization tool for Python, which is becoming a popular language for teaching introductory CS courses. Using this tool, teachers and students can write Python programs directly in the web browser (without installing any plugins), step forwards and backwards through execution to view the run-time state of data structures, and share their program visualizations on the web. In the past three years, over 200,000 people have used Online Python Tutor to visualize their programs. In addition, instructors in a dozen universities such as UC Berkeley, MIT, the University of Washington, and the University of Waterloo have used it in their CS1 courses. Finally, Online Python Tutor visualizations have been embedded within three web-based digital Python textbook projects, which collectively attract around 16,000 viewers per month and are being used in at least 25 universities. Online Python Tutor is free and open source software, available at pythontutor.com.},
booktitle = {Proceeding of the 44th ACM Technical Symposium on Computer Science Education},
pages = {579–584},
numpages = {6},
keywords = {CS1, python, program visualization},
location = {Denver, Colorado, USA},
series = {SIGCSE '13}
}

@inproceedings{10.1145/2950290.2950357,
author = {Xu, Zhaogui and Liu, Peng and Zhang, Xiangyu and Xu, Baowen},
title = {Python Predictive Analysis for Bug Detection},
year = {2016},
isbn = {9781450342186},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2950290.2950357},
doi = {10.1145/2950290.2950357},
abstract = { Python is a popular dynamic language that allows quick software development. However, Python program analysis engines are largely lacking. In this paper, we present a Python predictive analysis. It first collects the trace of an execution, and then encodes the trace and unexecuted branches to symbolic constraints. Symbolic variables are introduced to denote input values, their dynamic types, and attribute sets, to reason about their variations. Solving the constraints identifies bugs and their triggering inputs. Our evaluation shows that the technique is highly effective in analyzing real-world complex programs with a lot of dynamic features and external library calls, due to its sophisticated encoding design based on traces. It identifies 46 bugs from 11 real-world projects, with 16 new bugs. All reported bugs are true positives. },
booktitle = {Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
pages = {121–132},
numpages = {12},
keywords = {Debugging, Python, Predictive Analysis, Dynamic Language},
location = {Seattle, WA, USA},
series = {FSE 2016}
}

@inproceedings{10.1109/MSR.2019.00027,
author = {Zhai, Hongyu and Casalnuovo, Casey and Devanbu, Prem},
title = {Test Coverage in Python Programs},
year = {2019},
publisher = {IEEE Press},
url = {https://doi.org/10.1109/MSR.2019.00027},
doi = {10.1109/MSR.2019.00027},
abstract = {We study code coverage in several popular Python projects: flask, matplotlib, pandas, scikit-learn, and scrapy. Coverage data on these projects is gathered and hosted on the Codecov website, from where this data can be mined. Using this data, and a syntactic parse of the code, we examine the effect of control flow structure, statement type (e.g., if, for) and code age on test coverage. We find that coverage depends on control flow structure, with more deeply nested statements being significantly less likely to be covered. This is a clear effect, which holds up in every project, even when controlling for the age of the line (as determined by git blame). We find that the age of a line per se has a small (but statistically significant) positive effect on coverage. Finally, we find that the kind of statement (try, if, except, raise, etc) has varying effects on coverage, with exception-handling statements being covered much less often. These results suggest that developers in Python projects have difficulty writing test sets that cover deeply-nested and error-handling statements, and might need assistance covering such code.},
booktitle = {Proceedings of the 16th International Conference on Mining Software Repositories},
pages = {116–120},
numpages = {5},
keywords = {python, code age, mining, test coverage},
location = {Montreal, Quebec, Canada},
series = {MSR '19}
}

@inproceedings{10.1145/1873951.1874253,
author = {Nouvel, Bertrand and Satoh, Shin'Ichi},
title = {The Python Computer Vision Framework},
year = {2010},
isbn = {9781605589336},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1873951.1874253},
doi = {10.1145/1873951.1874253},
abstract = {PyCVF is an open source framework for computer vision and video-mining. It allows rapid development of applications and it provides standardized tools for common operations such as : browsing datasets, applying transformations to one dataset on-the-fly, computing features, indexing multimedia datasets, querying for nearest-neighbors, training a statistical model, or browsing the result in a 3d-space. PyCVF has a Python API, it also provides command line programs, QT Gui, and a web front-end. It can interacts nicely with other leading frameworks such as Weka, Orange, OpenCV, Django...},
booktitle = {Proceedings of the 18th ACM International Conference on Multimedia},
pages = {1481–1484},
numpages = {4},
keywords = {indexing, videomining, classification, software framework, python},
location = {Firenze, Italy},
series = {MM '10}
}

@inproceedings{10.1145/1409908.1409911,
author = {Snyder, Robin M.},
title = {Security Programming Using Python: Man-in-the-Middle Attacks},
year = {2007},
isbn = {9781595939098},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1409908.1409911},
doi = {10.1145/1409908.1409911},
abstract = {Many security concepts become more clear to students when operationalized in the context of a programming language. Unfortunately, many programming systems and development environments are complex and not easily learned or used. Python is a simple programming language system with extensive library support for programming in general and security programming in particular. This paper describes using Portable Python to teach security concepts in the context of man-in-the-middle attacks.},
booktitle = {Proceedings of the 4th Annual Conference on Information Security Curriculum Development},
articleno = {2},
numpages = {6},
keywords = {programming languages, Python, security, data communications},
location = {Kennesaw, Georgia},
series = {InfoSecCD '07}
}

@inproceedings{10.1145/1268784.1268937,
author = {Goldwasser, Michael H. and Letscher, David},
title = {Teaching Object-Oriented Programming in Python},
year = {2007},
isbn = {9781595936103},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1268784.1268937},
doi = {10.1145/1268784.1268937},
abstract = {Python's use in education has grown rapidly, due to its elegantly simple syntax. Though often viewed as a "scripting language," Python is a fully object-oriented language with an extremely consistent object model and a rich set of built-in classes.In this tutorial, we share our experiences using Python in the context of an object-oriented CS1 course. We will begin with an overview of the language, with particular emphasis on the object-orientation. We then present several coherent teaching strategies and a variety of graphical and non-graphical projects. Both new and experienced Python users are welcome.},
booktitle = {Proceedings of the 12th Annual SIGCSE Conference on Innovation and Technology in Computer Science Education},
pages = {365–366},
numpages = {2},
keywords = {object-orientation, CS1, python},
location = {Dundee, Scotland},
series = {ITiCSE '07}
}

@article{10.1145/1269900.1268937,
author = {Goldwasser, Michael H. and Letscher, David},
title = {Teaching Object-Oriented Programming in Python},
year = {2007},
issue_date = {September 2007},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {39},
number = {3},
issn = {0097-8418},
url = {https://doi.org/10.1145/1269900.1268937},
doi = {10.1145/1269900.1268937},
abstract = {Python's use in education has grown rapidly, due to its elegantly simple syntax. Though often viewed as a "scripting language," Python is a fully object-oriented language with an extremely consistent object model and a rich set of built-in classes.In this tutorial, we share our experiences using Python in the context of an object-oriented CS1 course. We will begin with an overview of the language, with particular emphasis on the object-orientation. We then present several coherent teaching strategies and a variety of graphical and non-graphical projects. Both new and experienced Python users are welcome.},
journal = {SIGCSE Bull.},
month = jun,
pages = {365–366},
numpages = {2},
keywords = {python, CS1, object-orientation}
}

@inproceedings{10.1145/3149869.3149870,
author = {Amela, Ramon and Ramon-Cortes, Cristian and Ejarque, Jorge and Conejero, Javier and Badia, Rosa M.},
title = {Enabling Python to Execute Efficiently in Heterogeneous Distributed Infrastructures with PyCOMPSs},
year = {2017},
isbn = {9781450351249},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3149869.3149870},
doi = {10.1145/3149869.3149870},
abstract = {Python has been adopted as programming language by a large number of scientific communities. Additionally to the easy programming interface, the large number of libraries and modules that have been made available by a large number of contributors, have taken this language to the top of the list of the most popular programming languages in scientific applications. However, one main drawback of Python is the lack of support for concurrency or parallelism. PyCOMPSs is a proved approach to support task-based parallelism in Python that enables applications to be executed in parallel in distributed computing platforms.This paper presents PyCOMPSs and how it has been tailored to execute tasks in heterogeneous and multi-threaded environments. We present an approach to combine the task-level parallelism provided by PyCOMPSs with the thread-level parallelism provided by MKL. Performance and behavioral results in distributed computing heterogeneous clusters show the benefits and capabilities of PyCOMPSs in both HPC and Big Data infrastructures.},
booktitle = {Proceedings of the 7th Workshop on Python for High-Performance and Scientific Computing},
articleno = {1},
numpages = {10},
keywords = {HPC, Python, Heterogeneous infrastructures, Linear Algebra, Big Data},
location = {Denver, CO, USA},
series = {PyHPC'17}
}

@inproceedings{10.1145/2964284.2973804,
author = {Belanger, Olivier},
title = {Pyo, the Python DSP Toolbox},
year = {2016},
isbn = {9781450336031},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2964284.2973804},
doi = {10.1145/2964284.2973804},
abstract = {This paper introduces pyo, a python module dedicated to the digital processing of sound. This audio engine distinguishes itself from other alternatives by being natively integrated to a common general programming language. This integration allows incorporating audio processes quickly to other programming tasks, like mathematical computations, network communications or graphical interface programming. We will expose the main features of the library as well as the different contexts of use where pyo can be of a great benefit to composers and audio software developers.},
booktitle = {Proceedings of the 24th ACM International Conference on Multimedia},
pages = {1214–1217},
numpages = {4},
keywords = {music computing, python, audio programming, digital signal processing},
location = {Amsterdam, The Netherlands},
series = {MM '16}
}

@inproceedings{10.1109/ASE.2019.00160,
author = {Li, Yu},
title = {Empirical Study of Python Call Graph},
year = {2019},
isbn = {9781728125084},
publisher = {IEEE Press},
url = {https://doi.org/10.1109/ASE.2019.00160},
doi = {10.1109/ASE.2019.00160},
abstract = {In recent years, the extensive application of the Python language has made its analysis work more and more valuable. Many static analysis algorithms need to rely on the construction of call graphs. In this paper, we did a comparative empirical analysis of several widely used Python static call graph tools both quantitatively and qualitatively. Experiments show that the existing Python static call graph tools have a large difference in the construction effectiveness, and there is still room for improvement.},
booktitle = {Proceedings of the 34th IEEE/ACM International Conference on Automated Software Engineering},
pages = {1274–1276},
numpages = {3},
keywords = {empirical study, quantitative, qualitative, Python, call graph},
location = {San Diego, California},
series = {ASE '19}
}

@inproceedings{10.1145/1731740.1731833,
author = {Leping, Vambola and Lepp, Marina and Niitsoo, Margus and T\~{o}nisson, Eno and Vene, Varmo and Villems, Anne},
title = {Python Prevails},
year = {2009},
isbn = {9781605589862},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1731740.1731833},
doi = {10.1145/1731740.1731833},
abstract = {In this article we describe why we changed the language of our introductory programming course for first year math and computer science students from Java to Python. We explain why we chose Python over the other languages, how we built up the course and how we ran it as an experiment with a small group (about 25% of students). The experiment itself lead us to decide to use Python with all the students starting the next, 2009/2010 study year.},
booktitle = {Proceedings of the International Conference on Computer Systems and Technologies and Workshop for PhD Students in Computing},
articleno = {87},
numpages = {5},
keywords = {Python as a first language, teaching programming to beginners},
location = {Ruse, Bulgaria},
series = {CompSysTech '09}
}

@inproceedings{10.1145/2597073.2597103,
author = {\r{A}kerblom, Beatrice and Stendahl, Jonathan and Tumlin, Mattias and Wrigstad, Tobias},
title = {Tracing Dynamic Features in Python Programs},
year = {2014},
isbn = {9781450328630},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2597073.2597103},
doi = {10.1145/2597073.2597103},
abstract = { Recent years have seen a number of proposals for adding (retrofitting) static typing to dynamic programming languages, a natural consequence of their growing popularity for non-toy applications across a multitude of domains. These proposals often make assumptions about how programmers write code, and in many cases restrict the way the languages can be used. In the context of Python, this paper describes early results from trace-based collection of run-time data about the use of built-in language features which are inherently hard to type, such as dynamic code generation. The end goal of this work is to facilitate static validation tooling for Python, in particular retrofitting of type systems. },
booktitle = {Proceedings of the 11th Working Conference on Mining Software Repositories},
pages = {292–295},
numpages = {4},
keywords = {Python, dynamic features, Dynamic languages, open source},
location = {Hyderabad, India},
series = {MSR 2014}
}

@inproceedings{10.1145/2816707.2816717,
author = {\r{A}kerblom, Beatrice and Wrigstad, Tobias},
title = {Measuring Polymorphism in Python Programs},
year = {2015},
isbn = {9781450336901},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2816707.2816717},
doi = {10.1145/2816707.2816717},
abstract = { Following the increased popularity of dynamic languages and their increased use in critical software, there have been many proposals to retrofit static type system to these languages to improve possibilities to catch bugs and improve performance. A key question for any type system is whether the types should be structural, for more expressiveness, or nominal, to carry more meaning for the programmer. For retrofitted type systems, it seems the current trend is using structural types. This paper attempts to answer the question to what extent this extra expressiveness is needed, and how the possible polymorphism in dynamic code is used in practise. We study polymorphism in 36 real-world open source Python programs and approximate to what extent nominal and structural types could be used to type these programs. The study is based on collecting traces from multiple runs of the programs and analysing the polymorphic degrees of targets at more than 7 million call-sites. Our results show that while polymorphism is used in all programs, the programs are to a great extent monomorphic. The polymorphism found is evenly distributed across libraries and program-specific code and occur both during program start-up and normal execution. Most programs contain a few ``megamorphic'' call-sites where receiver types vary widely. The non-monomorphic parts of the programs can to some extent be typed with nominal or structural types, but none of the approaches can type entire programs. },
booktitle = {Proceedings of the 11th Symposium on Dynamic Languages},
pages = {114–128},
numpages = {15},
keywords = {trace-based analysis, polymorphism, dynamic languages, Python},
location = {Pittsburgh, PA, USA},
series = {DLS 2015}
}

@article{10.1145/2936313.2816717,
author = {\r{A}kerblom, Beatrice and Wrigstad, Tobias},
title = {Measuring Polymorphism in Python Programs},
year = {2015},
issue_date = {Feburary 2016},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {2},
issn = {0362-1340},
url = {https://doi.org/10.1145/2936313.2816717},
doi = {10.1145/2936313.2816717},
abstract = { Following the increased popularity of dynamic languages and their increased use in critical software, there have been many proposals to retrofit static type system to these languages to improve possibilities to catch bugs and improve performance. A key question for any type system is whether the types should be structural, for more expressiveness, or nominal, to carry more meaning for the programmer. For retrofitted type systems, it seems the current trend is using structural types. This paper attempts to answer the question to what extent this extra expressiveness is needed, and how the possible polymorphism in dynamic code is used in practise. We study polymorphism in 36 real-world open source Python programs and approximate to what extent nominal and structural types could be used to type these programs. The study is based on collecting traces from multiple runs of the programs and analysing the polymorphic degrees of targets at more than 7 million call-sites. Our results show that while polymorphism is used in all programs, the programs are to a great extent monomorphic. The polymorphism found is evenly distributed across libraries and program-specific code and occur both during program start-up and normal execution. Most programs contain a few ``megamorphic'' call-sites where receiver types vary widely. The non-monomorphic parts of the programs can to some extent be typed with nominal or structural types, but none of the approaches can type entire programs. },
journal = {SIGPLAN Not.},
month = oct,
pages = {114–128},
numpages = {15},
keywords = {polymorphism, dynamic languages, trace-based analysis, Python}
}

@inproceedings{10.1145/3328778.3366906,
author = {Nanavati, Amal and Owens, Aileen and Stehlik, Mark},
title = {Pythons and Martians and Finches, Oh My! Lessons Learned from a Mandatory 8th Grade Python Class},
year = {2020},
isbn = {9781450367936},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3328778.3366906},
doi = {10.1145/3328778.3366906},
abstract = {As computing technologies continue to have a greater impact on daily life, it becomes increasingly important for the K-12 education system to prepare students for the computerized world. In this paper, we present the curriculum design, implementation, and results from a one-trimester introductory Python course that is mandatory for all 8th graders in our school district. This course is a crucial component of the K-12 computational thinking pathways we are developing at our school district, which take students from block-based programming and computational thinking (elementary school) to text-based programming and applications of computer science (high school). Our mandatory 8th grade course serves as a bridge between these two components. We present qualitative results that highlight the challenges that arose from teaching a course for all students -- not just those with a prior interest in computing -- and how the instructor overcame those challenges. We also present quantitative results that demonstrate the course's positive impact on students' attitudes towards computer science, their intent to re-engage with computer science in the future, and the gender gap with regards to confidence in computer science.},
booktitle = {Proceedings of the 51st ACM Technical Symposium on Computer Science Education},
pages = {811–817},
numpages = {7},
keywords = {k-12 computer science education, computational thinking, robotics},
location = {Portland, OR, USA},
series = {SIGCSE '20}
}

@inproceedings{10.1145/3281464.3281465,
author = {Loring, Burlen and Myers, Andrew and Camp, David and Bethel, E. Wes},
title = {Python-Based <i>in Situ</i> Analysis and Visualization},
year = {2018},
isbn = {9781450365796},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3281464.3281465},
doi = {10.1145/3281464.3281465},
abstract = {This work focuses on enabling the use of Python-based methods for the purpose of performing in situ analysis and visualization. This approach facilitates access to and use of a rapidly growing collection of Python-based, third-party libraries for analysis and visualization, as well as lowering the barrier to entry for user-written Python analysis codes. Beginning with a simulation code that is instrumented to use the SENSEI in situ interface, we present how to couple it with a Python-based data consumer, which may be run in situ, and in parallel at the same concurrency as the simulation. We present two examples that demonstrate the new capability. One is an analysis of the reaction rate in a proxy simulation of a chemical reaction on a 2D substrate, while the other is a coupling of an AMR simulation to Yt, a parallel visualization and analysis library written in Python. In the examples, both the simulation and Python in situ method run in parallel on a large-scale HPC platform.},
booktitle = {Proceedings of the Workshop on In Situ Infrastructures for Enabling Extreme-Scale Analysis and Visualization},
pages = {19–24},
numpages = {6},
keywords = {in situ visualization, Python, in situ analysis},
location = {Dallas, Texas, USA},
series = {ISAV '18}
}

@inproceedings{10.1145/1508865.1508907,
author = {Enbody, Richard J. and Punch, William F. and McCullen, Mark},
title = {Python CS1 as Preparation for C++ CS2},
year = {2009},
isbn = {9781605581835},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1508865.1508907},
doi = {10.1145/1508865.1508907},
abstract = {How suitable is a Python-based CS1 course as preparation for a C++-based CS2 course? After fifteen years of using C++ for both CS1 and CS2, the Computer Science Department at Michigan State University changed the CS1 course to Python. This paper examines the impact of that change on the second course in the sequence, CS2, which kept C++ as its primary language. We report results on a CS2 class which had a mixture of students who had used either C++ or Python from our CS1 course. The CS2 class covered the same topics as previously, though with some changes, and even gave the same final exam as a previous offering. Independent samples t-tests were used to compare students from the Python group with students from the non-Python group on three outcomes: final exam grade, programming projects scores, and final grade for the course. The main result was that there were no significant differences between the groups for all three outcomes. In addition, multiple regression analysis showed that students' past performance (overall GPA) in the University predicted final grades, final exam scores, and programming project scores for the course, but there was no effect of the programming language feature: Python or non-Python. We feel this shows that the Python-based CS1 course prepared students for the C++-based CS2 course as well as the C++-based CS1 course did---while exposing them to a different, powerful and useful language.},
booktitle = {Proceedings of the 40th ACM Technical Symposium on Computer Science Education},
pages = {116–120},
numpages = {5},
keywords = {python, cs2, intro. to programming, curriculum, cs1},
location = {Chattanooga, TN, USA},
series = {SIGCSE '09}
}

@article{10.1145/1539024.1508907,
author = {Enbody, Richard J. and Punch, William F. and McCullen, Mark},
title = {Python CS1 as Preparation for C++ CS2},
year = {2009},
issue_date = {March 2009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {41},
number = {1},
issn = {0097-8418},
url = {https://doi.org/10.1145/1539024.1508907},
doi = {10.1145/1539024.1508907},
abstract = {How suitable is a Python-based CS1 course as preparation for a C++-based CS2 course? After fifteen years of using C++ for both CS1 and CS2, the Computer Science Department at Michigan State University changed the CS1 course to Python. This paper examines the impact of that change on the second course in the sequence, CS2, which kept C++ as its primary language. We report results on a CS2 class which had a mixture of students who had used either C++ or Python from our CS1 course. The CS2 class covered the same topics as previously, though with some changes, and even gave the same final exam as a previous offering. Independent samples t-tests were used to compare students from the Python group with students from the non-Python group on three outcomes: final exam grade, programming projects scores, and final grade for the course. The main result was that there were no significant differences between the groups for all three outcomes. In addition, multiple regression analysis showed that students' past performance (overall GPA) in the University predicted final grades, final exam scores, and programming project scores for the course, but there was no effect of the programming language feature: Python or non-Python. We feel this shows that the Python-based CS1 course prepared students for the C++-based CS2 course as well as the C++-based CS1 course did---while exposing them to a different, powerful and useful language.},
journal = {SIGCSE Bull.},
month = mar,
pages = {116–120},
numpages = {5},
keywords = {curriculum, cs2, python, cs1, intro. to programming}
}

@inproceedings{10.1145/3236024.3264598,
author = {Spadini, Davide and Aniche, Maur\'{\i}cio and Bacchelli, Alberto},
title = {PyDriller: Python Framework for Mining Software Repositories},
year = {2018},
isbn = {9781450355735},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3236024.3264598},
doi = {10.1145/3236024.3264598},
abstract = {Software repositories contain historical and valuable information about the overall development of software systems. Mining software repositories (MSR) is nowadays considered one of the most interesting growing fields within software engineering. MSR focuses on extracting and analyzing data available in software repositories to uncover interesting, useful, and actionable information about the system. Even though MSR plays an important role in software engineering research, few tools have been created and made public to support developers in extracting information from Git repository. In this paper, we present PyDriller, a Python Framework that eases the process of mining Git. We compare our tool against the state-of-the-art Python Framework GitPython, demonstrating that PyDriller can achieve the same results with, on average, 50% less LOC and significantly lower complexity.  URL: https://github.com/ishepard/pydriller  Materials: https://doi.org/10.5281/zenodo.1327363  Pre-print: https://doi.org/10.5281/zenodo.1327411},
booktitle = {Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
pages = {908–911},
numpages = {4},
keywords = {Python, Git, Mining Software Repositories, GitPython},
location = {Lake Buena Vista, FL, USA},
series = {ESEC/FSE 2018}
}

@article{10.1145/1869746.1869758,
author = {B\"{a}lter, Olle and Bailey, Duane A.},
title = {Enjoying Python, Processing, and Java in CS1},
year = {2010},
issue_date = {December 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {1},
number = {4},
issn = {2153-2184},
url = {https://doi.org/10.1145/1869746.1869758},
doi = {10.1145/1869746.1869758},
abstract = {Here we describe an introductory course in computer science where we combined Python, Processing, and core Java. The main reason for this structure was to make the initial contact with programming as gentle, enjoyable, and understandable as possible, while still having the power of graphics and sufficient Java knowledge for more advanced courses in computer science. This course was designed with a few informal pedagogical principles that facilitated the students' abilities to learn how to learn on their own. Informal results suggest that students may be interested in a greater diversity of programming assignments.},
journal = {ACM Inroads},
month = dec,
pages = {28–32},
numpages = {5},
keywords = {Processing, student projects, introductory course, Python, Java}
}

@inproceedings{10.1145/2661088.2661101,
author = {Vitousek, Michael M. and Kent, Andrew M. and Siek, Jeremy G. and Baker, Jim},
title = {Design and Evaluation of Gradual Typing for Python},
year = {2014},
isbn = {9781450332118},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2661088.2661101},
doi = {10.1145/2661088.2661101},
abstract = {Combining static and dynamic typing within the same language offers clear benefits to programmers. It provides dynamic typing in situations that require rapid prototyping, heterogeneous data structures, and reflection, while supporting static typing when safety, modularity, and efficiency are primary concerns. Siek and Taha (2006) introduced an approach to combining static and dynamic typing in a fine-grained manner through the notion of type consistency in the static semantics and run-time casts in the dynamic semantics. However, many open questions remain regarding the semantics of gradually typed languages.In this paper we present Reticulated Python, a system for experimenting with gradual-typed dialects of Python. The dialects are syntactically identical to Python 3 but give static and dynamic semantics to the type annotations already present in Python 3. Reticulated Python consists of a typechecker and a source-to-source translator from Reticulated Python to Python 3. Using Reticulated Python, we evaluate a gradual type system and three approaches to the dynamic semantics of mutable objects: the traditional semantics based on Siek and Taha (2007) and Herman et al. (2007) and two new designs. We evaluate these designs in the context of several third-party Python programs.},
booktitle = {Proceedings of the 10th ACM Symposium on Dynamic Languages},
pages = {45–56},
numpages = {12},
keywords = {python, proxy, gradual typing, case study},
location = {Portland, Oregon, USA},
series = {DLS '14}
}

@article{10.1145/2775052.2661101,
author = {Vitousek, Michael M. and Kent, Andrew M. and Siek, Jeremy G. and Baker, Jim},
title = {Design and Evaluation of Gradual Typing for Python},
year = {2014},
issue_date = {February 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {2},
issn = {0362-1340},
url = {https://doi.org/10.1145/2775052.2661101},
doi = {10.1145/2775052.2661101},
abstract = {Combining static and dynamic typing within the same language offers clear benefits to programmers. It provides dynamic typing in situations that require rapid prototyping, heterogeneous data structures, and reflection, while supporting static typing when safety, modularity, and efficiency are primary concerns. Siek and Taha (2006) introduced an approach to combining static and dynamic typing in a fine-grained manner through the notion of type consistency in the static semantics and run-time casts in the dynamic semantics. However, many open questions remain regarding the semantics of gradually typed languages.In this paper we present Reticulated Python, a system for experimenting with gradual-typed dialects of Python. The dialects are syntactically identical to Python 3 but give static and dynamic semantics to the type annotations already present in Python 3. Reticulated Python consists of a typechecker and a source-to-source translator from Reticulated Python to Python 3. Using Reticulated Python, we evaluate a gradual type system and three approaches to the dynamic semantics of mutable objects: the traditional semantics based on Siek and Taha (2007) and Herman et al. (2007) and two new designs. We evaluate these designs in the context of several third-party Python programs.},
journal = {SIGPLAN Not.},
month = oct,
pages = {45–56},
numpages = {12},
keywords = {python, proxy, gradual typing, case study}
}

@inproceedings{10.1145/3356395.3365598,
author = {Roy, Avipsa and Fouch\'{e}, Edouard and Morales, Rafael Rodriguez and M\"{o}hler, Gregor},
title = {In-Database Geospatial Analytics Using Python},
year = {2019},
isbn = {9781450369541},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3356395.3365598},
doi = {10.1145/3356395.3365598},
abstract = {The amount of spatial data acquired from crowdsourced platforms, mobile devices, sensors and cartographic agencies has grown exponentially over the past few years. Nearly half of the spatial data available currently are stored and processed through large relational databases. Due to a lack of generic open source tools, researchers and analysts often have difficulty in extracting and analyzing large amounts of spatial data from traditional databases. In order to overcome this challenge, the most effective way is to perform the analysis directly in the database, which enables quick retrieval and visualization of spatial data stored in relational databases. Also, working in-database reduces the network overhead, as users do not need to replicate the complete data into their local system. While a number of spatial analysis libraries are readily available, they do not work in-database, and typically require additional platform-specific software. Our goal is to bridge this gap by developing a new method through an open source software to perform fast and seamless spatial analysis without having to store the data in-memory. We propose a framework implemented in Python, which embeds geospatial analytics into a spatial database (i.e. IBM DB2 ®). The framework internally translates the spatial functions written by the user into SQL queries, which follow the standards of Open Geospatial Consortium (OGC) and can operate on single as well as multiple geometries. We then demonstrate how to combine the results of spatial operations with visualization methods such as choropleth maps within Jupyter notebooks. Finally, we elaborate upon the benefits of our approach via a real-world use case, in which we analyze crime hotspots in New York City using the in-database spatial functions.},
booktitle = {Proceedings of the 2nd ACM SIGSPATIAL International Workshop on Advances on Resilient and Intelligent Cities},
pages = {17–24},
numpages = {8},
keywords = {spatial data, Maps, Python, crime analysis, In-database analytics, geospatial analytics},
location = {Chicago, IL, USA},
series = {ARIC'19}
}

@inproceedings{10.1109/MSR.2019.00042,
author = {Bafatakis, Nikolaos and Boecker, Niels and Boon, Wenjie and Salazar, Martin Cabello and Krinke, Jens and Oznacar, Gazi and White, Robert},
title = {Python Coding Style Compliance on Stack Overflow},
year = {2019},
publisher = {IEEE Press},
url = {https://doi.org/10.1109/MSR.2019.00042},
doi = {10.1109/MSR.2019.00042},
abstract = {Software developers all over the world use Stack Overflow (SO) to interact and exchange code snippets. Research also uses SO to harvest code snippets for use with recommendation systems. However, previous work has shown that code on SO may have quality issues, such as security or license problems.We analyse Python code on SO to determine its coding style compliance. From 1,962,535 code snippets tagged with 'python', we extracted 407,097 snippets of at least 6 statements of Python code. Surprisingly, 93.87% of the extracted snippets contain style violations, with an average of 0.7 violations per statement and a huge number of snippets with a considerably higher ratio. Researchers and developers should, therefore, be aware that code snippets on SO may not representative of good coding style.Furthermore, while user reputation seems to be unrelated to coding style compliance, for posts with vote scores in the range between -10 and 20, we found a strong correlation (r = -0.87, p &lt; 10-7) between the vote score a post received and the average number of violations per statement for snippets in such posts.},
booktitle = {Proceedings of the 16th International Conference on Mining Software Repositories},
pages = {210–214},
numpages = {5},
keywords = {style guides, stack overflow, python, code style, SOTorrent, coding style, coding conventions},
location = {Montreal, Quebec, Canada},
series = {MSR '19}
}

@inproceedings{10.1145/3079368.3079402,
author = {Niephaus, Fabio and Felgentreff, Tim and Pape, Tobias and Hirschfeld, Robert},
title = {Squeak Makes a Good Python Debugger: Bringing Other Programming Languages Into Smalltalk's Tools},
year = {2017},
isbn = {9781450348362},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3079368.3079402},
doi = {10.1145/3079368.3079402},
abstract = {Interactive debuggers are indispensable in many software development scenarios. However, they are often hard to extend and more importantly, their capabilities are limited to an application programming interface (API) provided by the runtime executing the corresponding programming language.We propose an approach that allows to use the live tools of a Smalltalk environment for other programming languages. The approach is based on interpreter-level composition, ultimately making a full-fledged integrated development environment (IDE) part of the language execution process. This allows to directly control interpreters of foreign languages from Smalltalk. It also enables tool reuse and provides the ability to rapidly build new tools.We demonstrate how we have combined Squeak/Smalltalk and PyPy's Python implementation. We then reused Squeak's debugger, so that it enables edit-and-continue style debugging of Python applications---which is currently not supported by Python's PDB or any Python IDE, but which has proven to be invaluable in many debugging scenarios.},
booktitle = {Companion to the First International Conference on the Art, Science and Engineering of Programming},
articleno = {27},
numpages = {8},
keywords = {IDEs, VMs, debuggers, Python, Smalltalk},
location = {Brussels, Belgium},
series = {Programming '17}
}

@inproceedings{10.1145/2950290.2950343,
author = {Xu, Zhaogui and Zhang, Xiangyu and Chen, Lin and Pei, Kexin and Xu, Baowen},
title = {Python Probabilistic Type Inference with Natural Language Support},
year = {2016},
isbn = {9781450342186},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2950290.2950343},
doi = {10.1145/2950290.2950343},
abstract = { We propose a novel type inference technique for Python programs. Type inference is difficult for Python programs due to their heavy dependence on external APIs and the dynamic language features. We observe that Python source code often contains a lot of type hints such as attribute accesses and variable names. However, such type hints are not reliable. We hence propose to use probabilistic inference to allow the beliefs of individual type hints to be propagated, aggregated, and eventually converge on probabilities of variable types. Our results show that our technique substantially outperforms a state-of-the-art Python type inference engine based on abstract interpretation. },
booktitle = {Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
pages = {607–618},
numpages = {12},
keywords = {Probabilistic Inference, Python, Dynamic Languages, Type Inference},
location = {Seattle, WA, USA},
series = {FSE 2016}
}

@inproceedings{10.1145/2509136.2509536,
author = {Politz, Joe Gibbs and Martinez, Alejandro and Milano, Matthew and Warren, Sumner and Patterson, Daniel and Li, Junsong and Chitipothu, Anand and Krishnamurthi, Shriram},
title = {Python: The Full Monty},
year = {2013},
isbn = {9781450323741},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2509136.2509536},
doi = {10.1145/2509136.2509536},
abstract = {We present a small-step operational semantics for the Python programming language. We present both a core language for Python, suitable for tools and proofs, and a translation process for converting Python source to this core. We have tested the composition of translation and evaluation of the core for conformance with the primary Python implementation, thereby giving confidence in the fidelity of the semantics. We briefly report on the engineering of these components. Finally, we examine subtle aspects of the language, identifying scope as a pervasive concern that even impacts features that might be considered orthogonal.},
booktitle = {Proceedings of the 2013 ACM SIGPLAN International Conference on Object Oriented Programming Systems Languages &amp; Applications},
pages = {217–232},
numpages = {16},
keywords = {serpents},
location = {Indianapolis, Indiana, USA},
series = {OOPSLA '13}
}

@article{10.1145/2544173.2509536,
author = {Politz, Joe Gibbs and Martinez, Alejandro and Milano, Matthew and Warren, Sumner and Patterson, Daniel and Li, Junsong and Chitipothu, Anand and Krishnamurthi, Shriram},
title = {Python: The Full Monty},
year = {2013},
issue_date = {October 2013},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {48},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/2544173.2509536},
doi = {10.1145/2544173.2509536},
abstract = {We present a small-step operational semantics for the Python programming language. We present both a core language for Python, suitable for tools and proofs, and a translation process for converting Python source to this core. We have tested the composition of translation and evaluation of the core for conformance with the primary Python implementation, thereby giving confidence in the fidelity of the semantics. We briefly report on the engineering of these components. Finally, we examine subtle aspects of the language, identifying scope as a pervasive concern that even impacts features that might be considered orthogonal.},
journal = {SIGPLAN Not.},
month = oct,
pages = {217–232},
numpages = {16},
keywords = {serpents}
}

@inproceedings{10.1145/2808006.2808017,
author = {Miller, Craig S. and Settle, Amber and Lalor, John},
title = {Learning Object-Oriented Programming in Python: Towards an Inventory of Difficulties and Testing Pitfalls},
year = {2015},
isbn = {9781450338356},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2808006.2808017},
doi = {10.1145/2808006.2808017},
abstract = {We report a small yet detailed study where we recorded students completing an object-oriented programming exercise in the context of a CS2 course using Python. All students struggled while completing the assignment, most notably experiencing difficulties with parameters and referencing elements with object-dot notation. While previous research has identified these areas as troublesome for novice programmers, our analysis suggests that parameters and reference specifications are particularly critical prerequisites for learning advanced object-oriented concepts with the Python programming language. Given our findings, we recommend extensive practice with parameter passing and object-dot notation before addressing advanced object-oriented concepts in a Python course.},
booktitle = {Proceedings of the 16th Annual Conference on Information Technology Education},
pages = {59–64},
numpages = {6},
keywords = {python, novice programming, reference errors, inheritance},
location = {Chicago, Illinois, USA},
series = {SIGITE '15}
}

@inproceedings{10.1145/1384271.1384368,
author = {Radenski, Atanas},
title = {Digital CS1 Study Pack Based on Moodle and Python},
year = {2008},
isbn = {9781605580784},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1384271.1384368},
doi = {10.1145/1384271.1384368},
abstract = {We believe that CS1 courses can be made more attractive to students: by teaching a highly interactive scripting language - Pythonby using an open source course management system - such as Moodle - to make all course resources available in a comprehensive digital study pack, andby offering detailed self-guided online labs.We have used Moodle [1] and Python [2] to develop a "Python First" digital study pack [3] which comprises a wealth of new, original learning modules: extensive e-texts, detailed self-guided labs, numerous sample programs, quizzes, and slides. Our digital study pack pedagogy is described in recent ITiCSE and SIGCSE papers [4, 5]. "Python First" digital packs instances have already been adopted by instructors at several universities. This demonstration reveals instructor and student perspectives to the "Python First" digital pack. In particular, we demonstrate how instructors can use standard Moodle functionality to customize and manage digital packs. We also demonstrate several Moodle-supported, Python-based self-guided labs.},
booktitle = {Proceedings of the 13th Annual Conference on Innovation and Technology in Computer Science Education},
pages = {325},
numpages = {1},
keywords = {active learning, Python, course management system, Moodle},
location = {Madrid, Spain},
series = {ITiCSE '08}
}

@article{10.1145/1597849.1384368,
author = {Radenski, Atanas},
title = {Digital CS1 Study Pack Based on Moodle and Python},
year = {2008},
issue_date = {September 2008},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {40},
number = {3},
issn = {0097-8418},
url = {https://doi.org/10.1145/1597849.1384368},
doi = {10.1145/1597849.1384368},
abstract = {We believe that CS1 courses can be made more attractive to students: by teaching a highly interactive scripting language - Pythonby using an open source course management system - such as Moodle - to make all course resources available in a comprehensive digital study pack, andby offering detailed self-guided online labs.We have used Moodle [1] and Python [2] to develop a "Python First" digital study pack [3] which comprises a wealth of new, original learning modules: extensive e-texts, detailed self-guided labs, numerous sample programs, quizzes, and slides. Our digital study pack pedagogy is described in recent ITiCSE and SIGCSE papers [4, 5]. "Python First" digital packs instances have already been adopted by instructors at several universities. This demonstration reveals instructor and student perspectives to the "Python First" digital pack. In particular, we demonstrate how instructors can use standard Moodle functionality to customize and manage digital packs. We also demonstrate several Moodle-supported, Python-based self-guided labs.},
journal = {SIGCSE Bull.},
month = jun,
pages = {325},
numpages = {1},
keywords = {active learning, Python, course management system, Moodle}
}

@inproceedings{10.1145/2330784.2330899,
author = {Park, Hyun soo and Kim, Kyung Joong},
title = {Automatic Python Programming Using Stack-Based Genetic Programming},
year = {2012},
isbn = {9781450311786},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2330784.2330899},
doi = {10.1145/2330784.2330899},
abstract = {Traditional genetic programming uses tree-like data structure to represent a program. It should be converted into a Lisp code, or needs a custom-made virtual machine or interpreter to execute the program generated. Recently, there is a study on genetic programming directly using Java bytecode, a practical intermediate language. It evolves a series of commands that manipulate stack and registers in the virtual machine and represents them with a simple list data structure instead of tree. Evolving the intermediate language is promising because 1) it is easy to combine an existing program with an automatically generated program, 2) there are several available development tools and environments for the language including virtual machine, decompiler, optimizer and so on, and 3) incorporating the list data structure into the evolutionary algorithm is simple and straightforward. In this research, we propose to evolve bytecode of Python programming language by stack-based genetic programming. Python is a flexible and popular programming language powered by plenty of research tools. For the evolution, we developed representation and genetic operations for the Python language. We report that the proposed method produced successful Python codes for two regression problems.},
booktitle = {Proceedings of the 14th Annual Conference Companion on Genetic and Evolutionary Computation},
pages = {641–642},
numpages = {2},
keywords = {python, genetic programming, bytecode, stack-based genetic programming},
location = {Philadelphia, Pennsylvania, USA},
series = {GECCO '12}
}

@inproceedings{10.5555/3019083.3019090,
author = {Li, Yuanzhe and Schwiebert, Loren},
title = {Boosting Python Performance on Intel Processors: A Case Study of Optimizing Music Recognition},
year = {2016},
isbn = {9781509052202},
publisher = {IEEE Press},
abstract = {We present a case study of optimizing a Python-based music recognition application on Intel Haswell Xeon processor. With support from Numpy and Scipy, Python addresses the requirements of the music recognition problem with math library utilization and special structures for data access. However, a general optimized Python application cannot fully utilize the latest high performance multicore processors. In this study, we survey an existing open-source music recognition application, written in Python, to explore the effect of applying changes to the Scipy and Numpy libraries to achieve full processor resource occupancy and reduce code latency. Instead of comparing across many different architectures, we focus on Intel high performance processors that have multiple cores and vector registers, and we attempt to preserve both user-friendliness and code scalability so that the revised library functions can be ported to other platforms and require no additional code changes.},
booktitle = {Proceedings of the 6th Workshop on Python for High-Performance and Scientific Computing},
pages = {52–58},
numpages = {7},
keywords = {vector processing, roofline, Python performance optimization},
location = {Salt Lake City, Utah},
series = {PyHPC '16}
}

@inproceedings{10.1145/2157136.2157353,
author = {Ortiz, Ariel},
title = {Web Development with Python and Django (Abstract Only)},
year = {2012},
isbn = {9781450310987},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2157136.2157353},
doi = {10.1145/2157136.2157353},
abstract = {Many instructors have already discovered the joy of teaching programming using the Python programming language. Now it's time to take Python to the next level. This workshop will introduce Django, an open source Python web framework that saves you time and makes web development fun. It's aimed at Computer Science instructors who want to teach how to build elegant web applications with minimal fuss. Django follows the Model-View-Controller (MVC) architectural pattern. Its goal is to ease the creation of complex, database-driven websites. Django emphasizes reusability and "pluggability" of components, rapid development, and the principle of DRY (Don't Repeat Yourself). Python is used throughout, even for settings, files, and data models. Topics that will be covered during the workshop include: setup and configuration, template language, and database integration through object-relational mapping. Participants should have some familiarity with Python, HTML and SQL. Laptop Required.},
booktitle = {Proceedings of the 43rd ACM Technical Symposium on Computer Science Education},
pages = {686},
numpages = {1},
keywords = {python, Django, MVC, Web development},
location = {Raleigh, North Carolina, USA},
series = {SIGCSE '12}
}

@inproceedings{10.1145/3149869.3149871,
author = {Krebber, Manuel and Barthels, Henrik and Bientinesi, Paolo},
title = {Efficient Pattern Matching in Python},
year = {2017},
isbn = {9781450351249},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3149869.3149871},
doi = {10.1145/3149869.3149871},
abstract = {Pattern matching is a powerful tool for symbolic computations. Applications include term rewriting systems, as well as the manipulation of symbolic expressions, abstract syntax trees, and XML and JSON data. It also allows for an intuitive description of algorithms in the form of rewrite rules. We present the open source Python module MatchPy, which offers functionality and expressiveness similar to the pattern matching in Mathematica. In particular, it includes syntactic pattern matching, as well as matching for commutative and/or associative functions, sequence variables, and matching with constraints. MatchPy uses new and improved algorithms to efficiently find matches for large pattern sets by exploiting similarities between patterns. The performance of MatchPy is investigated on several real-world problems.},
booktitle = {Proceedings of the 7th Workshop on Python for High-Performance and Scientific Computing},
articleno = {2},
numpages = {9},
location = {Denver, CO, USA},
series = {PyHPC'17}
}

@inproceedings{10.1145/3287324.3287503,
author = {Liu, David and Petersen, Andrew},
title = {Static Analyses in Python Programming Courses},
year = {2019},
isbn = {9781450358903},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3287324.3287503},
doi = {10.1145/3287324.3287503},
abstract = {Students learning to program often rely on feedback from the compiler and from instructor-provided test cases to help them identify errors in their code. This feedback focuses on functional correctness, and the output, which is often phrased in technical language, may be difficult to for novices to understand or effectively use. Static analyses may be effective as a complementary aid, as they can highlight common errors that may be potential sources of problems. In this paper, we introduce PyTA, a wrapper for pylint that provides custom checks for common novice errors as well as improved messages to help students fix the errors that are found. We report on our experience integrating PyTA into an existing online system used to deliver programming exercises to CS1 students and evaluate it by comparing exercise submissions collected from the integrated system to previously collected data. This analysis demonstrates that, for students who chose to read the PyTA output, we observed a decrease in time to solve errors, occurrences of repeated errors, and submissions to complete a programming problem. This suggests that PyTA, and static analyses in general, may help students identify functional issues in their code not highlighted by compiler feedback and that static analysis output may help students more quickly identify debug their code.},
booktitle = {Proceedings of the 50th ACM Technical Symposium on Computer Science Education},
pages = {666–671},
numpages = {6},
keywords = {static analysis, errors, error messages, cs1, python},
location = {Minneapolis, MN, USA},
series = {SIGCSE '19}
}

@inproceedings{10.1145/1534530.1534550,
author = {Ben Asher, Yosi and Rotem, Nadav},
title = {The Effect of Unrolling and Inlining for Python Bytecode Optimizations},
year = {2009},
isbn = {9781605586236},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1534530.1534550},
doi = {10.1145/1534530.1534550},
abstract = {In this study, we consider bytecode optimizations for Python, a programming language which combines object-oriented concepts with features of scripting languages, such as dynamic dictionaries. Due to its design nature, Python is relatively slow compared to other languages. It operates through compiling the code into powerful bytecode instructions that are executed by an interpreter. Python's speed is limited due to its interpreter design, and thus there is a significant need to optimize the language. In this paper, we discuss one possible approach and limitations in optimizing Python based on bytecode transformations. In the first stage of the proposed optimizer, the bytecode is expanded using function inline and loop unrolling. The second stage of transformations simplifies the bytecode by applying a complete set of data-flow optimizations, including constant propagation, algebraic simplifications, dead code elimination, copy propagation, common sub expressions elimination, loop invariant code motion and strength reduction. While these optimizations are known and their implementation mechanism (data flow analysis) is well developed, they have not been successfully implemented in Python due to its dynamic features which prevent their use. In this work we attempt to understand the dynamic features of Python and how these features affect and limit the implementation of these optimizations. In particular, we consider the significant effects of first unrolling and then inlining on the ability to apply the remaining optimizations. The results of our experiments indicate that these optimizations can indeed be implemented and dramatically improve execution times.},
booktitle = {Proceedings of SYSTOR 2009: The Israeli Experimental Systems Conference},
articleno = {14},
numpages = {14},
keywords = {bytecode, Python, dynamic languages, optimizations},
location = {Haifa, Israel},
series = {SYSTOR '09}
}

@inproceedings{10.1145/3149869.3149872,
author = {Varela, Javier Alejandro and Wehn, Norbert and Desmettre, Sascha and Korn, Ralf},
title = {Real-Time Financial Risk Measurement of Dynamic Complex Portfolios with Python and PyOpenCL},
year = {2017},
isbn = {9781450351249},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3149869.3149872},
doi = {10.1145/3149869.3149872},
abstract = {Risk measures, such as value-at-risk and expected shortfall, are widely used to keep track of the risk at which a financial portfolio is exposed. This analysis is not only a key part of the daily operation of financial institutions worldwide, but it is also strictly enforced by regulators. While nested Monte Carlo simulations are the most flexible approach that can even deal with portfolios containing complicated derivatives, they traditionally suffer from a high computational complexity. This limits their application at certain intervals of time, mostly daily, by temporarily keeping the composition of the portfolio static.In this work, we bring together for the first time nested Monte Carlo simulations with the real-time continuous risk measurement of complex portfolios that dynamically change their composition during intraday operation. By combining the development productivity offered by Python, state-of-the-art mathematical optimizations, and the high performance capabilities offered by PyOpenCL targeting heterogeneous computing systems, our new approach reaches a throughput between 16 and 191 trading orders per second per computing node, which corresponds to the worst-case and best-case scenarios respectively.We have also made use of the Jupyter Notebook, as an interactive interface in an interdisciplinary research environment.},
booktitle = {Proceedings of the 7th Workshop on Python for High-Performance and Scientific Computing},
articleno = {3},
numpages = {10},
keywords = {python, value-at-risk, expected shortfall, jupyter notebook, finance, pyopencl, nested Monte Carlo simulations, component value-at-risk, real-time portfolio risk management},
location = {Denver, CO, USA},
series = {PyHPC'17}
}

@inproceedings{10.1145/3383219.3383255,
author = {Rao, A. Eashaan and Chimalakonda, Sridhar},
title = {An Exploratory Study Towards Understanding Lambda Expressions in Python},
year = {2020},
isbn = {9781450377317},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3383219.3383255},
doi = {10.1145/3383219.3383255},
abstract = {Lambda expressions are anonymous functions in Python. It is one of the alternatives to write a function definition. Syntactically, it is a single expression and defined using the keyword lambda. Lambda expression is a functional programming feature, currently in use, in many mainstream programming languages such as Python, Java8, C++11. There are few studies in C++ and Java to understand the impact of lambda expressions on programmers. These studies are focusing on the developer's adaptability to use a functional style of construct and the benefit they gain from using it. However, we are not aware of any literature on the use of lambda expressions in Python. Thus, there is a need to study lambda expressions in Python projects. In this paper, we examine 15 GitHub repositories out of 760 from our dataset, that are using Python as their primary language. In this study, we are classifying the uses of lambda expressions based on varying scenarios. We identified 13 different usages of lambda expressions from these Python repositories. This catalog is an attempt to support programmers to use lambda expressions more effectively and efficiently.},
booktitle = {Proceedings of the Evaluation and Assessment in Software Engineering},
pages = {318–323},
numpages = {6},
keywords = {Lambda Expressions, Programming Language Constructs, Empirical Study, Python},
location = {Trondheim, Norway},
series = {EASE '20}
}

@article{10.1145/2560032,
author = {Logaras, Evangelos and Hazapis, Orsalia G. and Manolakos, Elias S.},
title = {Python to Accelerate Embedded SoC Design: A Case Study for Systems Biology},
year = {2014},
issue_date = {November 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {13},
number = {4},
issn = {1539-9087},
url = {https://doi.org/10.1145/2560032},
doi = {10.1145/2560032},
abstract = {We present SysPy (System Python) a tool which exploits the strengths of the popular Python scripting language to boost design productivity of embedded System on Chips for FPGAs. SysPy acts as a “glue” software between mature HDLs, ready-to-use VHDL components and programmable processor soft IP cores. SysPy can be used to: (i) automatically translate hardware components described in Python into synthesizable VHDL, (ii) capture top-level structural descriptions of processor-centric SoCs in Python, (iii) implement all the steps necessary to compile the user's C code for an instruction set processor core and generate processor specific Tcl scripts that import to the design project all the necessary HDL files of the processor's description and instantiate/connect the core to other blocks in a synthesizable top-level Python description. Moreover, we have developed a Hardware Abstraction Layer (HAL) in Python which allows user applications running in a host PC to utilize effortlessly the SoC's resources in the FPGA. SysPy's design capabilities, when complemented with the developed HAL software API, provide all the necessary tools for hw/sw partitioning and iterative design for efficient SoC's performance tuning. We demonstrate how SysPy's design flow and functionalities can be used by building a processor-centric embedded SoC for computational systems biology. The designed SoC, implemented using a Xilinx Virtex-5 FPGA, combines the flexibility of a programmable soft processor core (Leon3) with the high performance of an application specific core to simulate flexibly and efficiently the stochastic behavior of large size biomolecular reaction networks. Such networks are essential for studying the dynamics of complex biological systems consisting of multiple interacting pathways.},
journal = {ACM Trans. Embed. Comput. Syst.},
month = mar,
articleno = {84},
numpages = {25},
keywords = {SoC, Python, scripting languages, Gillespie's Stochastic Simulation Algorithm, FPGA, VHDL, SysPy, Biomolecular reaction networks, Systems Biology, hw/sw co-design}
}

@inproceedings{10.1145/2828959.2828969,
author = {Annamaa, Aivar},
title = {Introducing Thonny, a Python IDE for Learning Programming},
year = {2015},
isbn = {9781450340205},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2828959.2828969},
doi = {10.1145/2828959.2828969},
abstract = {Thonny is a new Python IDE for learning and teaching programming that can make program visualization a natural part of the beginners' workflow. Among its prominent features are different ways of stepping through the code, step-by-step expression evaluation, intuitive visualization of the call stack and mode for explaining the concepts of references and heap. It supports educational research by logging user actions for replaying or analyzing the programming process. It is free to use and open for extension.},
booktitle = {Proceedings of the 15th Koli Calling Conference on Computing Education Research},
pages = {117–121},
numpages = {5},
keywords = {computing education, Python, programming, program visualization, program animation, IDE},
location = {Koli, Finland},
series = {Koli Calling '15}
}

@inproceedings{10.1145/3373509.3373540,
author = {Javed, Aaquib and Zaman, Monika and Uddin, M. Monir and Nusrat, Tasnova},
title = {An Analysis on Python Programming Language Demand and Its Recent Trend in Bangladesh},
year = {2019},
isbn = {9781450376570},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3373509.3373540},
doi = {10.1145/3373509.3373540},
abstract = {In today's world, we have a lot of programming languages. Which can realize our needs, but the important issue is, how to teach programming language in a very effective way to freshmen. Well, in that case, python can be a suitable language for both learning and real-world programming. It is a high-level, object-oriented programming language created by Guido Van Rossum was released in 1991. After python released day by day, it has become one of the most famous and demanding programming languages all over the world. In this paper will introduce and discuss python programming characteristics / features, organized syntax, and its powerful tools which help to solve many tasks also it is very close to simple math thinking. We tried to find out the recent trend/demand for python programming language in Bangladesh by operated a survey under faculty member from various universities, freelancer programmers and students from engineering studies. Also, make some simple comparison between python and other languages. From there we have figure out the most demanding features, characteristics of python language and the types of programming language supported by python. Python is now the most demanded and fastest-growing language which is founded by the support of researches done over many articles of various magazines and popular websites.},
booktitle = {Proceedings of the 2019 8th International Conference on Computing and Pattern Recognition},
pages = {458–465},
numpages = {8},
keywords = {Survey in Bangladesh, programming language, career in python, python trend, Python},
location = {Beijing, China},
series = {ICCPR '19}
}

@inproceedings{10.1109/MSR.2019.00086,
author = {Biswas, Sumon and Islam, Md Johirul and Huang, Yijia and Rajan, Hridesh},
title = {Boa Meets Python: A Boa Dataset of Data Science Software in Python Language},
year = {2019},
publisher = {IEEE Press},
url = {https://doi.org/10.1109/MSR.2019.00086},
doi = {10.1109/MSR.2019.00086},
abstract = {The popularity of Python programming language has surged in recent years due to its increasing usage in Data Science. The availability of Python repositories in Github presents an opportunity for mining software repository research, e.g., suggesting the best practices in developing Data Science applications, identifying bug-patterns, recommending code enhancements, etc. To enable this research, we have created a new dataset that includes 1,558 mature Github projects that develop Python software for Data Science tasks. By analyzing the metadata and code, we have included the projects in our dataset which use a diverse set of machine learning libraries and managed by a variety of users and organizations. The dataset is made publicly available through Boa infrastructure both as a collection of raw projects as well as in a processed form that could be used for performing large scale analysis using Boa language. We also present two initial applications to demonstrate the potential of the dataset that could be leveraged by the community.},
booktitle = {Proceedings of the 16th International Conference on Mining Software Repositories},
pages = {577–581},
numpages = {5},
keywords = {MSR, machine learning, data science, Boa, program analysis, open source repositories, AST},
location = {Montreal, Quebec, Canada},
series = {MSR '19}
}

@inproceedings{10.1145/3394451.3397205,
author = {Monat, Rapha\"{e}l and Ouadjaout, Abdelraouf and Min\'{e}, Antoine},
title = {Value and Allocation Sensitivity in Static Python Analyses},
year = {2020},
isbn = {9781450379977},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3394451.3397205},
doi = {10.1145/3394451.3397205},
abstract = {Sound static analyses for large subsets of static programming languages such as C are now widespread. For example the Astr\'{e}e static analyzer soundly overapproximates the behavior of C programs that do not contain any dynamic code loading, longjmp statements nor recursive functions. The sound and precise analysis of widely used dynamic programming languages like JavaScript and Python remains a challenge. This paper examines the variation of static analyses of Python – in precision, time and memory usage – by adapting three parameters: the value sensitivity, the allocation sensitivity and the activation of an abstract garbage collector . It is not clear yet which level of sensitivity constitutes a sweet spot in terms of precision versus efficiency to achieve a meaningful Python analysis. We thus perform an experimental evaluation using a prototype static analyzer on benchmarks a few thousand lines long. Key findings are: the value analysis does not improve the precision over type-related alarms; the value analysis is three times costlier than the type analysis; the allocation sensitivity depends on the value sensitivity; using an abstract garbage collector lowers memory usage and running times, but does not affect precision.},
booktitle = {Proceedings of the 9th ACM SIGPLAN International Workshop on the State Of the Art in Program Analysis},
pages = {8–13},
numpages = {6},
keywords = {Python, Abstract Interpretation, Dynamic Programming Language, Heap Abstraction, Recency Abstraction, Static Analysis, Experimental Evaluation, Formal Methods},
location = {London, UK},
series = {SOAP 2020}
}

